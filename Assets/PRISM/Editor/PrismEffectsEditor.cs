using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.IO;
using Prism.Utils;
//
#if UNITY_EDITOR
[CustomEditor(typeof(PrismEffects), true)]
[CanEditMultipleObjects]
public class PrismEffectsEditor : Editor
{

	SerializedObject serObj;

	string currentEffectsString = "";

	private Texture2D tempClutTex2D;
	private Texture2D tempSecondClutTex2D;

	bool showToneParams = false;

	static bool needsToSave = false;
	string extraSaveString = "";
	string extraLoadString = "";
	PrismPreset preset;

	static bool showBloom = true;
	static bool showChromatic = true;
	static bool showVignette = true;
	static bool showNoise = true;
	static bool showDof = true;
	static bool showAdvancedBloom = false;
//	static bool showAdvancedRays = false;
	static bool showTonemap = true;
//static bool showColorify = true;
	static bool showFog = true;
//	static bool showRays = true;
	static bool showExposure = true;
	static bool showLut = true;
//static bool showNV = true;
	static bool showAO = true;

	GUIContent bloomContent = new GUIContent ("Use Bloom", "Simulates the light fringing & bleeding artifacts of a camera lens");
	GUIContent bloomTypeContent = new GUIContent ("   >Bloom Type", "The method used to create the bloom texture. HDR bloom is recommended for any HDR scene, simple bloom is marginally cheaper and works better with LDR/stylised scenes.");
	GUIContent bloomTextureSizeContent = new GUIContent ("   >Bloom Downsample", "Increasing this value offers more performance, and a larger bloom area, at the cost of temporal stability");
	GUIContent bloomThreshTypeContent = new GUIContent ("   >Bloom Threshold Method", "Gradual: Better for 'full-screen' bloom, Highlights: great for only blooming very bright areas, Curve: Like gradual, but more expensive and more control");
	public GUIContent bloomBlurPassesContent = new GUIContent ("   >Bloom Blur Passes", "# of blur passes to apply to the bloom texture. More blur passes are more expensive, particularly if you are using a large base bloom texture");
	GUIContent bloomIntensityContent = new GUIContent ("   >Bloom Intensity", "Increases the intensity of the bloom effect");
//GUIContent bloomExposureContent = new GUIContent("   >Bloom Exposure", "Adjusts the amount of exposure applied to the bloom texture");
	GUIContent bloomThresholdContent = new GUIContent ("   >Bloom Threshold", "(OPTIONAL) - The bloom threshold may be desirable in scenes where you only want the brightest pixels to contribute to bloom");
	GUIContent bloomKneeContent = new GUIContent ("   >Bloom Knee", "Knee of the quadratic curve");
	GUIContent bloomRadContent = new GUIContent ("   >Bloom Radius", "Radius of the blur filter used when blooming. Warning: Setting too high may cause cache misses (lower performance) - always profile before and after you set this");
	GUIContent bloomStabilityContent = new GUIContent ("   >Use Stablility Buffer", "Uses the previous frames bloom texture to reduce 'firefly' artifacts");
	GUIContent bloomLensDirtContent = new GUIContent ("   >Use Lens Dirt", "Applies the lens dirt texture to brighter areas of the image");

	GUIContent bloomLensDirtTextureContent = new GUIContent ("     >Lens Dirt Texture", "Requires alpha channel");
	GUIContent bloomLensDirtIntensityContent = new GUIContent ("     >Lens Dirt Intensity", "Increases the intensity of the lens dirt texture");
	GUIContent bloomDebugTextureContent = new GUIContent ("   >Show Bloom Texture", "Shows you the bloom texture that is generated by the bloom pre-pass. Useful for debugging");
	GUIContent bloomBlurScreenContent = new GUIContent ("     >Blur screen with bloom tex", "(Does not work with DoF) - Blurs the screen using the generated bloom texture, which has already undergone blur passes");
	GUIContent bloomUseScreenAddContent = new GUIContent ("   >Use Screen Blend", "A smoother way of blending the bloom texture to the main texture, which also retains more detail. Only available in LDR.");

	GUIContent bloomAdvancedContent = new GUIContent ("   Show Advanced Values", "");

	GUIContent bloomFlaresContent = new GUIContent ("   >Use Lens Flares", "Applies a screen-space lens flare to the image using a modified bloom texture");
	GUIContent bloomFlareIntensityContent = new GUIContent ("     >Flare Intensity", "Intensity of the lens flares in the final image");
	GUIContent bloomFlareChromContent = new GUIContent ("     >Flare Chrom. Aberration", "Intensity of the chromatic aberration/distortion in the flare");
	GUIContent bloomFlareGhostNumContent = new GUIContent ("     >Flare # of Ghosts", "Number of elements in the flare");
	GUIContent bloomFlareGhostSpaceContent = new GUIContent ("     >Flare Ghost Spacing", "Distance of each element of the flare away from the last one");
	GUIContent bloomFlareHaloContent = new GUIContent ("     >Flare Halo Width", "Width of the halo of the flare");
	//GUIContent bloomFlareColorTexContent = new GUIContent ("     >Flare Color Texture", "Color of lens flare across the screen");
		GUIContent bloomStarburstColorTexContent = new GUIContent ("     >Flare Starburst Texture", "Starburst texture to add a diffraction pattern and color onto the flare");
		GUIContent bloomFlareDirtMultContent = new GUIContent ("     >Flare Dirt Multiplier", "Scales the intensity of the lens dirt effect that is added to the flares texture.");

	GUIContent bloomUseUIBlurContent = new GUIContent ("   >Use Bloom tex for UI blur", "Stores the blurred full-screen texture generated by the bloom effect for use with the PRISM/UI Blur shader. That shader will fallback to a lower performance GrabPass method if this is not checked.");
	GUIContent bloomUIBlurPassNumberContent = new GUIContent ("     >Blur pass to grab from", "The bloom blur pass number that we will grab the full-screen blur texture from, the earlier the pass, the less blur. No performance impact.");

	GUIContent chromaticContent = new GUIContent ("Use Chromatic Aberration", "Simulates 'color fringing' optical lens effect");
	GUIContent chromaticIntensityContent = new GUIContent ("   >Chromatic Intensity", "Increases the intensity of the chromatic abberation effect");
	GUIContent chromaticTypeContent = new GUIContent ("   >Aberration Type", "Vignette aberration applies to the corners of the image, vertical aberration applies to the vertical edges");

	GUIContent chromaticBlurContent = new GUIContent ("   >Blur Edges", "Applies a blur to the areas of the screen affected by chromatic aberration. Requires 2 additional blur passes.");
	GUIContent chromaticBlurWidthContent = new GUIContent ("     >Edge Blur Amount", "The width of the blur applied. Does not affect performance.");

	GUIContent dofContent = new GUIContent ("Use Depth of Field", "Simulates camera lens defocus & bokeh artifacts");
	GUIContent dofRadiusContent = new GUIContent ("   >DoF Radius", "Increases maximum blur radius and bokeh size. No impact on performance");
	GUIContent dofSampleContent = new GUIContent ("   >DoF Sample Count", "Increases size of blur & bokeh, large impact on performance. Low is suitable in most cases");
	GUIContent dofBokehFactorContent = new GUIContent ("   >DoF Bokeh Factor", "Increases propensity to generate Bokeh");
	GUIContent dofPointContent = new GUIContent ("   >DoF Focus Point", "Distance at which to focus the camera");
	GUIContent dofNearPointContent = new GUIContent ("     >DoF Near Focus Point", "Distance at which to focus the camera for near blur");
	GUIContent dofDistanceContent = new GUIContent ("   >DoF Focus Range", "DoF blur plane distance until it reaches maximum blur");
	GUIContent dofNearblurContent = new GUIContent ("   >Use Near Blur", "When ticked, the Depth of Field will also blur pixels near the camera and outside of focal range");
	GUIContent dofNearDistanceContent = new GUIContent ("     >DoF Near Focus Range", "DoF close blur plane distance until it reaches maximum blur");
	public GUIContent dofMedianContent = new GUIContent ("   >Use Median Filter", "Shares a median filter (for stability) with other effects - disable this on mobile");
	GUIContent dofBlurSkyboxContent = new GUIContent ("   >Blur Skybox", "If enabled, the DoF effect will blur the skybox");
	GUIContent dofStabContent = new GUIContent ("     >Use DoF Stablility Buffer", "If enabled, passes the screen through a median filter to generate a more stable texture for Bokeh (if ticked, this texture is also used for more stable Godrays and Bloom)");
	GUIContent dofDebugContent = new GUIContent ("     >Visualise Focus", "Shows you the focus of the camera, where white is fully focused, and black is fully blurred. Useful for debugging");
	public GUIContent dofAdvancedContent = new GUIContent ("   Show Advanced Values", "Show advanced variables of the DoF effect");
	GUIContent dofDownsampleContent = new GUIContent ("     >DoF Downsample", "Increasing this value offers more performance, and a larger blur area, at the cost of temporal stability");

	GUIContent vignetteContent = new GUIContent ("Use Vignette", "Darkens the corners of the image");
//GUIContent advVignetteContent = new GUIContent("   >Show Advanced Values", "Exposes the vignette start and end variables of the vignette, for a more controlled effect");

	GUIContent noiseContent = new GUIContent ("Use Filmic Noise", "Adds semi-procedural filmic noise across the image");
	GUIContent noiseIntensityContent = new GUIContent ("   >Noise Intensity", "Increases the intensity of the noise effect");

	GUIContent sharpenContent = new GUIContent ("Use Sharpen", "Applys an edge-detecting sharpen filter");
	GUIContent sharpenIntensityContent = new GUIContent ("   >Sharpen Intensity", "Increases the intensity of the Sharpen (default: 0.4)");

	GUIContent brightContent = new GUIContent ("Use Brightness", "Performs a nice brightness amplification to some parts of the image");
	GUIContent brightIntensityContent = new GUIContent ("   >Brightness Intensity", "Increases the intensity of the effect");
	GUIContent brightCutoffContent = new GUIContent ("   >Brightness Cutoff", "The cutoff point of the brightness curve");
	GUIContent brightSoftnessContent = new GUIContent ("   >B. Cutoff Softness", "The slope of the brightness curve");

	GUIContent tonemapContent = new GUIContent ("Use Tonemap", "Transforms color from Linear into Gamma color space");
	GUIContent tonemapTypeContent = new GUIContent ("   >Tonemap Type", "Filmic = Advanced filmic tonemap, only really affects HDR colors. RomB = similar, but with very nice deep colors");
	GUIContent tonemapParamsContent = new GUIContent ("   >Tonemap Parameters", "Depending on what type of tonemapping you are using, these change different points in the tonemapping algorithm. In most cases, you shouldn't need to change them");
	GUIContent tonemapSecondaryParamsContent = new GUIContent ("   >Secondary Tonemap Params", "Depending on what type of tonemapping you are using, these change different points in the tonemapping algorithm. In most cases, you shouldn't need to change them");
//	GUIContent tonemapShowParamsContent = new GUIContent("   >Show Raw Values", "Depending on what type of tonemapping you are using, these change different points in the tonemapping algorithm. In most cases, you shouldn't need to change them");

	GUIContent gammaCorrectionContent = new GUIContent ("Use Gamma Correction", "Applies gamma correction to the final color of the image. Some monitors have slightly different base gamma values, so the gamma value should normally be user-set");
	GUIContent gammaValueContent = new GUIContent ("   >Gamma Value", "Some monitors have slightly different base gamma values, so the gamma value should normally be user-set");

	GUIContent exposureAdaptContent = new GUIContent ("Use Exposure Adaptation", "Simulates the ambient light response as human eyes adjust when going from a bright environment into a dark environment or vice versa");
	GUIContent exposureSpeedContent = new GUIContent ("   >Exposure Speed", "The normalized delta-speed at which the 'eye' texture adapts towards the new value");
//GUIContent exposureMultContent = new GUIContent("   >Exposure Multiplier", "Increases the intensity of the effect");
	GUIContent exposureOffsetContent = new GUIContent ("   >Exposure Offset", "Changes the 'default' exposure value of the 'eye' by applying an offset");
	GUIContent exposureMinContent = new GUIContent ("   >Minimum Exposure", "The minimum value that exposure will be clamped to (not an actual camera exposure value)");
	GUIContent exposureMatContent = new GUIContent ("   >Maximum Exposure", "The maximum value that exposure will be clamped to (not an actual camera exposure value)");
	GUIContent exposureDebugContent = new GUIContent ("   >View adaptation texture", "Render the exposure texture to half the screen, to visualise how fast it changes");

	GUIContent lutContent = new GUIContent ("Use Color Correction LUT", "Replaces the standard colour palette with a new palette based on a lookup texture");
	GUIContent lutInfoContent = new GUIContent ("   >Lookup Texture", "Texture to base the 3D Lookup texture on");
	GUIContent lutSecondaryInfoContent = new GUIContent ("   >Use Secondary LUT", "Allows a secondary LUT texture to be used");

	GUIContent fogContent = new GUIContent ("Use Fog", "Simulates a fog effect, which increases in intensity over distance, occluding distant objects");
//GUIContent fogIntensityContent = new GUIContent("   >Fog Intensity", "Maximum thickness of the fog effect");
	GUIContent fogColorContent = new GUIContent ("   >Fog Start Color", "Color of the fog closest to the camera");
	//GUIContent fogStartPointContent = new GUIContent ("   >Fog Start Point", "Distance away from the camera at which fog starts to occur");
	//GUIContent fogEndPointContent = new GUIContent ("   >Fog End Point", "Distance away from the camera at which the end color begins to blend in");
	GUIContent fogTypeContent = new GUIContent ("   >Fog Type", "The method used to fade the fog in. ");
	public GUIContent fogNoiseContent = new GUIContent ("   >Fog Noise Intensity", "Strength of the 'wind'/noise in the fog");
	GUIContent fogDistanceContent = new GUIContent ("   >Fog Distance", "Range in units that the fog takes to reach maximum intensity");
	GUIContent fogAffectSkyboxContent = new GUIContent ("   >Apply to Skybox", "Applies the fog regardless of depth");

	GUIContent aoContent = new GUIContent ("Use Ambient Obscurance", "Applies a screen-space ambient obscurance effect which approximates basic global illumination");
	GUIContent aoIntensityContent = new GUIContent ("   >AO Intensity", "Darkness of the AO effect");
	GUIContent aoBlurPassesContent = new GUIContent ("   >AO Blur Passes", "Number of bilateral blur passes performed on the AO texture. Moderate performance impact.");
//GUIContent aoBlurFilterDistanceContent = new GUIContent("   >AO Blur Filter Distance", "Scales the distance of the AO blur effect, resulting in a larger/smaller blur");
	GUIContent aoDownsampleContent = new GUIContent ("   >Use AO Downsample", "Perform all AO calculations at half resolution, saving performance.");
	GUIContent aoRadiusContent = new GUIContent ("   >AO Radius", "The radius that the AO effect samples around geometry for occlusion");
	GUIContent aoDepthTypeContent = new GUIContent ("   >AO Depth Method", "What texture the AO should grab Depth from (Ideally: Gbuffer (if using deferred), then Depth, then Depthnormals)");
    public GUIContent aoBiasContent = new GUIContent("     >AO Bias", "Increases the distance required between geometry to cause AO. Useful for fixing artifacts.");
    public GUIContent aoContrastContent = new GUIContent("     >AO Contrast", "Determines the contrast of the occlusion. Changing this will result in AO either underoccluding or overoccluding, but may be desired in some nonrealistic (eg lowpoly) scenes");
    public GUIContent aoLightingContent = new GUIContent ("     >AO Lighting Contribution", "Weights the AO based on the base lightness of the pixel, so that brighter pixels (like those lit by direct light) don't get AO applied");
	public GUIContent aoDebugContent = new GUIContent ("   >View AO Texture", "Debug view of the AO-only texture");

	public GUIContent aoUseCutoffContent = new GUIContent ("     >Use AO Cutoff", "Fade the AO effect out over distance");
	public GUIContent aoAdvancedContent = new GUIContent ("   Show Advanced Values", "Show advanced variables of the AO effect");
	public GUIContent aoCutoffStartContent = new GUIContent ("       >AO Cutoff Start", "Start fading the AO out at this distance from the camera (Units)");
	public GUIContent aoCutoffRangeContent = new GUIContent ("       >AO Cutoff Range", "Fade the AO effect out over this range (Units)");

	public GUIContent aoBlurTypeContent = new GUIContent ("     >AO Blur type", "Changes the type of Bilateral blur the AO uses. Fast = ~15% faster per pass than Wide, but Wide performs a 'blurrier' blur");
	public GUIContent aoSampleQualityContent = new GUIContent ("   >AO Sample Amount", "Takes more samples per pixel as increases. Can have a large impact on performance, particularly when not downsampling");

	/*GUIContent raysContent = new GUIContent ("Use Godrays", "Simulates fake light scattering (Crepuscular Rays) when looking at a ray caster");
	GUIContent raysWeightContent = new GUIContent ("   >Rays Weight", "Weight of the Rays effect. Around 0.5-0.6 is usually a good value");
	GUIContent raysColorContent = new GUIContent ("   >Rays Color", "Main Color of the rays cast");
	GUIContent raysThresholdContent = new GUIContent ("   >Rays Threshold", "Colors darker than this will be excluded from the blurring pass of the rays effect");
	GUIContent raysCasterContent = new GUIContent ("   >Ray Caster", "The transform that the rays should come from (Usuall a directional light)");
	GUIContent raysDebugContent = new GUIContent ("   >Show Rays Texture", "Renders a debug view of the rays texture");
	public GUIContent raysAdvancedContent = new GUIContent ("   Show Advanced Values", "Show advanced variables of the godrays effect");*/
	public GUIContent rayDecayContent = new GUIContent ("       >Ray Decay", "The amount at which the rays intensity decrease as they get further away from the sun");
	public GUIContent rayExposureContent = new GUIContent ("       >Ray Exposure", "The exposure of the sun while grabbing the rays texture - helps with blending (default 0.2)");
	public GUIContent rayDensityContent = new GUIContent ("       >Ray Density", "How close the samples of each ray are taken together");
	public GUIContent rayDownsampleContent = new GUIContent ("       >Ray Downsample", "Quarter is recommended for most games, but for slightly sharper rays, use half");

	GUIContent colorifyContent = new GUIContent ("Use Color Enhance", "Enhances the colors of pixels");
	GUIContent colorifyAmountContent = new GUIContent ("   >Color Intensity", "Amount of color enhancement to apply (default 0.4)");

	static bool hasDisplayedTonemapWarning = false;
	static bool hasDisplacedHDRWarning = false;
	static bool hasDisplayedGBufferWarning = false;

//	ColorPickerHDRConfig defaultHDRColorPicker = new ColorPickerHDRConfig (0f, 8f, 0.125f, 3f);

	void OnEnable ()
	{

		serObj = new SerializedObject (target);
	}

	public override void OnInspectorGUI ()
	{
		serObj.Update ();

		PrismEffects prism = target as PrismEffects;

		GUIContent PrismPresetContent;
		if (prism.currentPrismPreset) {
			PrismPresetContent = new GUIContent ("PRISM Preset:", "Preset description: " + prism.currentPrismPreset.PresetDescription);
		} else {
			PrismPresetContent = new GUIContent ("PRISM Preset:", "");
		}		 

//Preset
		EditorGUI.BeginChangeCheck ();
		preset = (PrismPreset)EditorGUILayout.ObjectField (PrismPresetContent, prism.currentPrismPreset, typeof(PrismPreset), false);
		if (EditorGUI.EndChangeCheck ()) {
			Undo.RecordObject (target, "Change prism preset");
			extraLoadString = "";
			if (preset.presetType == PrismPresetType.Full) {
				prism.currentPrismPreset = preset;
			}
			LoadValuesFromPreset (prism, preset);
			return;
		}

		EditorGUILayout.BeginHorizontal ();

		if (prism.currentPrismPreset) {
			if (needsToSave) {
				extraSaveString = "";
			} else
				extraSaveString = "";

			if (GUILayout.Button ("Save to preset" + extraSaveString)) {
				SaveValuesToPreset (prism, prism.currentPrismPreset);
				return;
			} else if (GUILayout.Button (extraLoadString + "Reset to preset")) {
				extraLoadString = "";
				prism.currentPrismPreset = preset;
				LoadValuesFromPreset (prism, prism.currentPrismPreset);
				return;
			} else if (GUILayout.Button ("Save as new preset")) {
				CreatePrismPresetAsset ();
				prism.currentPrismPreset = (PrismPreset)Selection.activeObject as PrismPreset;
				SaveValuesToPreset (prism, prism.currentPrismPreset);
				Selection.activeObject = prism;
			} else if (GUILayout.Button ("Clear preset")) {
				prism.currentPrismPreset = null;
				prism.SetPrismPreset (null);
				Selection.activeObject = prism;
			}
		} else {
			if (GUILayout.Button ("Create PRISM Preset")) {
				CreatePrismPresetAsset ();
				prism.currentPrismPreset = (PrismPreset)Selection.activeObject as PrismPreset;
				Selection.activeObject = prism;
			}
		}


		EditorGUILayout.EndHorizontal ();

		EditorGUILayout.Space ();

//Start the horizontal (2 per line) GUI layour
		EditorGUILayout.BeginVertical ();

		ResetCurrentEffectsString (prism);

		EditorGUILayout.LabelField ("Current effects: ");

		EditorGUILayout.LabelField (new GUIContent (currentEffectsString, currentEffectsString));
		EditorGUILayout.EndVertical ();


		EditorGUILayout.Space ();

//Bloom
		EditorGUILayout.BeginHorizontal ();

		prism.useBloom = EditorGUILayout.Toggle (bloomContent, prism.useBloom);
		EditorGUILayout.EndHorizontal ();

		if (prism.useBloom)
			showBloom = EditorGUILayout.Foldout (showBloom, " >Show Bloom Values");

		if (prism.useBloom && showBloom) {			
			EditorGUI.BeginChangeCheck ();
			BloomType blmType = (BloomType)EditorGUILayout.EnumPopup (bloomTypeContent, prism.bloomType);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Blm type");
				prism.bloomType = blmType;

				if (blmType == BloomType.HDR) {
					prism.bloomIntensity = Mathf.Min (prism.bloomIntensity, 0.065f);
				}
			}	

			EditorGUI.BeginChangeCheck ();
			float blmIntensity = EditorGUILayout.Slider (bloomIntensityContent, prism.bloomIntensity, 0f, 5f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Blm Intense");
				prism.bloomIntensity = blmIntensity;
			}

			EditorGUI.BeginChangeCheck ();
			Prism.Utils.BloomThreshholdType blmTType = (Prism.Utils.BloomThreshholdType)EditorGUILayout.EnumPopup (bloomThreshTypeContent, prism.bloomThreshType);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Thresh type");
				prism.bloomThreshType = blmTType;
			}

			EditorGUI.BeginChangeCheck ();
			float blmThresh = EditorGUILayout.Slider (bloomThresholdContent, prism.bloomThreshold, 0f, 2.0f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Blm Thresh");
				prism.bloomThreshold = blmThresh;
			}		

			if (prism.bloomThreshType == Prism.Utils.BloomThreshholdType.Quadratic) {
				float blmKnee = EditorGUILayout.Slider (bloomKneeContent, prism.bloomKnee, 0f, 2.0f);
//if(EditorGUI.EndChangeCheck())
//{
//Undo.RecordObject(target, "Blm knee");
				prism.bloomKnee = blmKnee;
//}
			}
			
			if (prism.bloomType != BloomType.HDR) {
				if (prism.GetPrismCamera ().allowHDR == false) {
					EditorGUI.BeginChangeCheck ();
					bool blmBlendMode = EditorGUILayout.Toggle (bloomUseScreenAddContent, prism.bloomUseScreenBlend);
					if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "Blm blend");
						prism.bloomUseScreenBlend = blmBlendMode;
					}
				}
			} else {
				
				if (prism.GetPrismCamera ().allowHDR == false) {
					EditorGUILayout.HelpBox ("You are using HDR bloom on a camera that is not set to HDR, or you have an LDR image effect before PRISM.", MessageType.Warning);
				}
			}

			EditorGUI.BeginChangeCheck ();
			bool bloomAdv = EditorGUILayout.Toggle (bloomAdvancedContent, showAdvancedBloom);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Blm adv");
				showAdvancedBloom = bloomAdv;
			}

			if(showAdvancedBloom)
			{
				EditorGUI.BeginChangeCheck ();
				int blmBlurPasses = EditorGUILayout.IntSlider (bloomBlurPassesContent, prism.bloomBlurPasses, 1, 3);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blur Bloom");
					prism.bloomBlurPasses = blmBlurPasses;
				}	

				EditorGUI.BeginChangeCheck ();
				float blmRad = EditorGUILayout.Slider (bloomRadContent, prism.bloomRadius, 0f, 8.0f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm Rad");
					prism.bloomRadius = blmRad;
				}	
				
				EditorGUI.BeginChangeCheck ();
				bool blmStab = EditorGUILayout.Toggle (bloomStabilityContent, prism.useBloomStability);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm Stab");
					prism.useBloomStability = blmStab;
					if(prism.useBloomStability == false && (EditorUserBuildSettings.activeBuildTarget == BuildTarget.Android || EditorUserBuildSettings.activeBuildTarget == BuildTarget.iOS))
					{
						prism.dofForceEnableMedian = false;
					}
				}
				
				EditorGUI.BeginChangeCheck ();
				Prism.Utils.BloomDownsampleAmount blmdsa = (Prism.Utils.BloomDownsampleAmount)EditorGUILayout.EnumPopup (bloomTextureSizeContent, prism.bloomDownsampleEnum);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Downsample");
					prism.bloomDownsampleEnum = blmdsa;
					prism.bloomDownsample = (int)blmdsa;
				}	
				
				EditorGUI.BeginChangeCheck ();
				bool uiblur = EditorGUILayout.Toggle (bloomUseUIBlurContent, prism.useUIBlur);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm uiblur");
					prism.useUIBlur = uiblur;
					prism.Reset ();
				}
				
				if (uiblur == true && prism.bloomType != BloomType.HDR) {
					EditorGUI.BeginChangeCheck ();
					int uiblurPassNum = EditorGUILayout.IntSlider (bloomUIBlurPassNumberContent, prism.uiBlurGrabTextureFromPassNumber, 0, prism.bloomBlurPasses - 1);
					if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "Blur passnum");
						prism.uiBlurGrabTextureFromPassNumber = uiblurPassNum;
					}			
				}

				EditorGUI.BeginChangeCheck ();
				bool blrScrn = EditorGUILayout.Toggle (bloomBlurScreenContent, prism.useFullScreenBlur);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm blur");
					prism.useFullScreenBlur = blrScrn;
					if (blrScrn == true) {
						if (prism.useDof == false) {
							prism.dofForceEnableMedian = true;
						} else {
							Debug.LogWarning ("You cannot use this feature with DoF, as it blurs the screen anyway. Turn off DoF to use.");
						}
					} else {
						prism.dofForceEnableMedian = false;
					}
				}
			}

			EditorGUI.BeginChangeCheck ();
			bool blmDirt = EditorGUILayout.Toggle (bloomLensDirtContent, prism.useLensDirt);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Blm Dirt");
				prism.useLensDirt = blmDirt;
			}

			if (blmDirt) {
				float maxDirtIntens = 1.0f;

				EditorGUI.BeginChangeCheck ();
				prism.lensDirtTexture = (Texture2D)EditorGUILayout.ObjectField (bloomLensDirtTextureContent, prism.lensDirtTexture, typeof(Texture2D), false);

				EditorGUI.BeginChangeCheck ();
				float drtInten = EditorGUILayout.Slider (bloomLensDirtIntensityContent, prism.dirtIntensity, 0f, maxDirtIntens);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm Dirt intens");
					prism.dirtIntensity = drtInten;
				}
			}

			EditorGUI.BeginChangeCheck ();
			bool blmFlares = EditorGUILayout.Toggle (bloomFlaresContent, prism.useBloomFlares);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Blm flares");
				prism.useBloomFlares = blmFlares;
			}

			if (blmFlares) {
				EditorGUI.BeginChangeCheck ();
				float flareInten = EditorGUILayout.Slider (bloomFlareIntensityContent, prism.bloomFlareStrength, 0f, 2f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm flare intens");
					prism.bloomFlareStrength = flareInten;
				}

				EditorGUI.BeginChangeCheck ();
				float flareDirtMult = EditorGUILayout.Slider (bloomFlareDirtMultContent, prism.bloomFlareLensDirtIntensityMultiplier, 0.00001f, 10f);
				if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "Blm flare intens");
						prism.bloomFlareLensDirtIntensityMultiplier = flareDirtMult;
				}

				EditorGUI.BeginChangeCheck ();
				float flareHaloWidth = EditorGUILayout.Slider (bloomFlareHaloContent, prism.bloomFlareHaloWidth, 0f, 2f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm flare hal width");
					prism.bloomFlareHaloWidth = flareHaloWidth;
				}

				EditorGUI.BeginChangeCheck ();
				float flareGDisp = EditorGUILayout.Slider (bloomFlareGhostSpaceContent, prism.bloomFlareGhostDispersal, 0f, 2f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm flare g disp");
					prism.bloomFlareGhostDispersal = flareGDisp;
				}

				EditorGUI.BeginChangeCheck ();
				float flareChromDist = EditorGUILayout.Slider (bloomFlareChromContent, prism.bloomFlareChromaticDistortion, 0f, 2f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm flare chrom dist");
					prism.bloomFlareChromaticDistortion = flareChromDist;
				}

				EditorGUI.BeginChangeCheck ();
				int flareGhoNum = EditorGUILayout.IntSlider (bloomFlareGhostNumContent, prism.bloomFlareNumberGhosts, 0, 8);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Blm flare chrom dist");
					prism.bloomFlareNumberGhosts = flareGhoNum;
				}

				//prism.bloomFlareRadialColorTex = (Texture2D)EditorGUILayout.ObjectField (bloomFlareColorTexContent, prism.bloomFlareRadialColorTex, typeof(Texture2D), false);

				prism.bloomFlareStarburstTex = (Texture2D)EditorGUILayout.ObjectField (bloomStarburstColorTexContent, prism.bloomFlareStarburstTex, typeof(Texture2D), false);

			}

			EditorGUI.BeginChangeCheck ();
			bool debgBlmTex = EditorGUILayout.Toggle (bloomDebugTextureContent, prism.debugBloomTex);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Blm Dbg");
				prism.debugBloomTex = debgBlmTex;
			}

//if(prism.useDof == false)
//{

		}

		GUILayout.Space (1f);

//Fog
		EditorGUILayout.BeginHorizontal ();

		prism.useFog = EditorGUILayout.Toggle (fogContent, prism.useFog);
		EditorGUILayout.EndHorizontal ();

		if (prism.useFog)
			showFog = EditorGUILayout.Foldout (showFog, " >Show Fog Values");

		if (prism.useFog && showFog) {	

			EditorGUI.BeginChangeCheck ();
			FogType fogType = (FogType)EditorGUILayout.EnumPopup (fogTypeContent, prism.fogExpFactor);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog Exponential type");
				prism.fogExpFactor = fogType;
			}

			EditorGUI.BeginChangeCheck ();
			Color fogStartCol = EditorGUILayout.ColorField (fogColorContent, prism.fogColor);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog1 color");
				prism.fogColor = fogStartCol;
			}
/*EditorGUI.BeginChangeCheck();
float fogInten = EditorGUILayout.Slider(fogIntensityContent, prism.fogIntensity, 0f, 1.0f);
if(EditorGUI.EndChangeCheck())
{
Undo.RecordObject(target, "Fog intens");
prism.fogIntensity = fogInten;
}*/

			/*EditorGUI.BeginChangeCheck ();
			float fogStart = EditorGUILayout.FloatField (fogStartPointContent, prism.fogStartPoint);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog start");
				prism.fogStartPoint = fogStart;
			}

			EditorGUI.BeginChangeCheck ();
			Color fogStartCol = EditorGUILayout.ColorField (fogColorContent, prism.fogColor);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog1 color");
				prism.fogColor = fogStartCol;
			}

			EditorGUI.BeginChangeCheck ();
			float fogMid = EditorGUILayout.FloatField (fogMidPointContent, prism.fogMidPoint);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog mid");
				prism.fogMidPoint = fogMid;
			}

			EditorGUI.BeginChangeCheck ();
			Color fogMidCol = EditorGUILayout.ColorField (fogColorMidContent, prism.fogMidColor);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog1.5 color");
				prism.fogMidColor = fogMidCol;
			}

			EditorGUI.BeginChangeCheck ();
			float fogEn = EditorGUILayout.FloatField (fogEndPointContent, prism.fogEndPoint);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog en");
				prism.fogEndPoint = fogEn;
			}

			EditorGUI.BeginChangeCheck ();
			Color fogEndCol = EditorGUILayout.ColorField (fogColorEndContent, prism.fogEndColor);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog2 color");
				prism.fogEndColor = fogEndCol;
			}*/

			/*EditorGUI.BeginChangeCheck ();
			float fogEn = EditorGUILayout.Slider (fogNoiseContent, prism.fogNoiseFactor1, 0.0f, 0.2f );
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog noise");
				prism.fogNoiseFactor1 = fogEn;
				prism.fogNoiseFactor2 = fogEn * 5f;
			}*/

			EditorGUI.BeginChangeCheck ();
			//Mathf.Max (0.1f, 0.1f + prism.fogStartPoint)
			float fogDist = EditorGUILayout.Slider (fogDistanceContent, prism.fogDistance, 0.01f, prism.GetPrismCamera().farClipPlane);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Fog d");
				prism.fogDistance = fogDist;
			}

			EditorGUI.BeginChangeCheck ();
			bool fogSkybox = EditorGUILayout.Toggle (fogAffectSkyboxContent, prism.fogAffectSkybox);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "fog blur skybox");
				prism.fogAffectSkybox = fogSkybox;
			}


		}

		GUILayout.Space (1f);

//Dof
		EditorGUILayout.BeginHorizontal ();

		prism.useDof = EditorGUILayout.Toggle (dofContent, prism.useDof);
		EditorGUILayout.EndHorizontal ();

		if (prism.useDof)
			showDof = EditorGUILayout.Foldout (showDof, " >Show DoF Values");

		if (prism.useDof && showDof) {
			EditorGUI.BeginChangeCheck ();
			float dofRadius = EditorGUILayout.Slider (dofRadiusContent, prism.dofRadius, 0f, 2.0f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Dof rad");
				prism.dofRadius = dofRadius;
			}

			EditorGUI.BeginChangeCheck ();
			DoFSamples dofSamples = (DoFSamples)EditorGUILayout.EnumPopup (dofSampleContent, prism.dofSampleAmount);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Dof SampleQual");
				prism.dofSampleAmount = dofSamples;
			}

			EditorGUI.BeginChangeCheck ();
			float dofFactor = EditorGUILayout.Slider (dofBokehFactorContent, prism.dofBokehFactor, 0f, 300.0f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Dof factor");
				prism.dofBokehFactor = dofFactor;
			}

			EditorGUI.BeginChangeCheck ();
			float dofPoint = EditorGUILayout.FloatField (dofPointContent, prism.dofFocusPoint);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Dof point");
				prism.dofFocusPoint = dofPoint;
			}

			EditorGUI.BeginChangeCheck ();
			float dofDist = EditorGUILayout.Slider (dofDistanceContent, prism.dofFocusDistance, 0f, 100.0f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Dof point");
				prism.dofFocusDistance = dofDist;
			}

			EditorGUI.BeginChangeCheck ();
			bool dofBlurSkybox = EditorGUILayout.Toggle (dofBlurSkyboxContent, prism.dofBlurSkybox);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Dof blur skybox");
				prism.dofBlurSkybox = dofBlurSkybox;
			}

		/*	EditorGUI.BeginChangeCheck ();
			bool dofuseMRT = EditorGUILayout.Toggle ("   >Use MultipleRenderTargets", prism.dofUseMRT);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Dof blur mrt");
				prism.dofUseMRT = dofuseMRT;
			}*/

/*EditorGUI.BeginChangeCheck();
bool dofDICEBlur = EditorGUILayout.Toggle("   >Use DICE Blur", prism.useDICEDof);
if(EditorGUI.EndChangeCheck())
{
Undo.RecordObject(target, "Dof blur DICE");
prism.useDICEDof = dofDICEBlur;
}*/

			EditorGUI.BeginChangeCheck ();
			bool dofNearBlur = EditorGUILayout.Toggle (dofNearblurContent, prism.useNearDofBlur);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Dof blur");
				prism.useNearDofBlur = dofNearBlur;
			}

			/*EditorGUI.BeginChangeCheck ();
			bool dofmed = EditorGUILayout.Toggle (dofMedianContent, prism.dofForceEnableMedian);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Dof median");
				prism.dofForceEnableMedian = dofmed;
			}*/

			EditorGUI.BeginChangeCheck ();
			bool dofAdvanced = EditorGUILayout.Toggle (dofAdvancedContent, prism.advancedDof);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "dof adv");
				prism.advancedDof = dofAdvanced;
			}

			if(prism.advancedDof)
			{
				if (prism.useNearDofBlur) {
					EditorGUI.BeginChangeCheck ();
					float dofNearPoint = EditorGUILayout.FloatField (dofNearPointContent, Mathf.Min(prism.dofFocusPoint, prism.dofNearFocusPoint));
					if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "Dof point");
						prism.dofNearFocusPoint = dofNearPoint;
					}
					
					EditorGUI.BeginChangeCheck ();
					float dofNearDist = EditorGUILayout.Slider (dofNearDistanceContent, prism.dofNearFocusDistance, prism.dofNearFocusPoint + 0.1f, 100.0f);
					if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "Dof dist near");
						prism.dofNearFocusDistance = dofNearDist;
					}
				}
				
				EditorGUI.BeginChangeCheck ();
				bool dofStab = EditorGUILayout.Toggle (dofStabContent, prism.dofForceEnableMedian);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Dof stab");
					prism.dofForceEnableMedian = dofStab;
				}
				
				EditorGUI.BeginChangeCheck ();
				BloomDownsampleAmount dofDownAmount = (BloomDownsampleAmount)EditorGUILayout.EnumPopup (dofDownsampleContent, prism.dofDownsample);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "dof downsample type");
					prism.dofDownsample = dofDownAmount;
				}
				
				EditorGUI.BeginChangeCheck ();
				bool dofDebug = EditorGUILayout.Toggle (dofDebugContent, prism.debugDofPass);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Dof debg");
					prism.debugDofPass = dofDebug;
				}
				
				if (dofDebug) {
					EditorGUI.BeginChangeCheck ();
					DebugDofPass dofDebugType = (DebugDofPass)EditorGUILayout.EnumPopup (dofDebugContent, prism.dofDebugType);
					if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "dof debug type");
						prism.dofDebugType = dofDebugType;
					}
				}
			}
			



		}


		GUILayout.Space (1f);

//Dof
		EditorGUILayout.BeginHorizontal ();

		prism.useAmbientObscurance = EditorGUILayout.Toggle (aoContent, prism.useAmbientObscurance);
		EditorGUILayout.EndHorizontal ();

		if (prism.useAmbientObscurance)
			showAO = EditorGUILayout.Foldout (showAO, " >Show AO Values");

		if (prism.useAmbientObscurance && showAO) {

			EditorGUI.BeginChangeCheck ();
			float aoIntens = EditorGUILayout.Slider (aoIntensityContent, prism.aoIntensity, 0f, 2.5f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "AO int");
				prism.aoIntensity = aoIntens;
			}

			EditorGUI.BeginChangeCheck ();
			float aoRad = EditorGUILayout.Slider (aoRadiusContent, prism.aoRadius, 0f, 2.0f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "AO Rad");
				prism.aoRadius = aoRad;
			}

			EditorGUI.BeginChangeCheck ();
			SampleCount aoSamples = (SampleCount)EditorGUILayout.EnumPopup (aoSampleQualityContent, prism.aoSampleCount);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "ao SampleQual");
				prism.aoSampleCount = aoSamples;
			}

			EditorGUI.BeginChangeCheck ();
			int aoBlurNum = EditorGUILayout.IntSlider (aoBlurPassesContent, prism.aoBlurIterations, 0, 3);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "AO Blur#");
				prism.aoBlurIterations = aoBlurNum;
			}

			EditorGUI.BeginChangeCheck ();
			PrismEffects.OcclusionSource occSrc = (PrismEffects.OcclusionSource)EditorGUILayout.EnumPopup (aoDepthTypeContent, prism.occlusionSource);
			if (EditorGUI.EndChangeCheck ()) {
				if (occSrc == PrismEffects.OcclusionSource.GBuffer && prism.GetPrismCamera ().renderingPath != RenderingPath.DeferredShading) {
					Debug.LogWarning ("There is no GBuffer unless you're using deferred rendering!");

				} else {
					Undo.RecordObject (target, "AO depthsource#");
					prism.occlusionSource = occSrc;
					prism.Reset ();
				}
			}

			EditorGUI.BeginChangeCheck ();
			bool aoDown = EditorGUILayout.Toggle (aoDownsampleContent, prism.aoDownsample);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "AO downs");
				prism.aoDownsample = aoDown;
			}

			EditorGUI.BeginChangeCheck ();
			bool aoAdvanced = EditorGUILayout.Toggle (aoAdvancedContent, prism.advancedAO);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "AO adv");
				prism.advancedAO = aoAdvanced;
			}

			if (prism.advancedAO) {
				if (!prism.IsGBufferAvailable) {
					if (!hasDisplayedGBufferWarning) {
//Debug.Log("You are not currently using deferred rendering. PRISM.AO works best in deferred, and will switch to a slightly lower quality AO in forward rendering");
						hasDisplayedGBufferWarning = true;
					}
				}

				EditorGUI.BeginChangeCheck ();
				float aolghtbs = EditorGUILayout.Slider (aoLightingContent, prism.aoLightingContribution, 0f, 1.0f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "AO lgt");
					prism.aoLightingContribution = aolghtbs;
				}

				EditorGUI.BeginChangeCheck ();
				float aobs = EditorGUILayout.Slider (aoBiasContent, prism.aoBias, 0f, 1.0f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "AO bs");
					prism.aoBias = aobs;
				}

//if(prism.IsGBufferAvailable)
//{
				EditorGUI.BeginChangeCheck ();
				AOBlurType aoblurtype = (AOBlurType)EditorGUILayout.EnumPopup (aoBlurTypeContent, prism.aoBlurType);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "ao blurtype");
					prism.aoBlurType = aoblurtype;
				}
//} else {
//	prism.aoBlurType = AOBlurType.Fast;
//}

				EditorGUI.BeginChangeCheck ();
				bool aoCut = EditorGUILayout.Toggle (aoUseCutoffContent, prism.useAODistanceCutoff);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "AO downs");
					prism.useAODistanceCutoff = aoCut;
				}

				if (prism.useAODistanceCutoff) {
					if (prism.useDof) {
						EditorGUILayout.HelpBox ("When Depth Of Field and AO is used, PRISM will automatically apply an AO cutoff as the DoF fades in, to prevent harsh lines.", MessageType.Info);
					}

//Cutoff stuff
					EditorGUI.BeginChangeCheck ();
					float aoStartD = EditorGUILayout.Slider (aoCutoffStartContent, prism.aoDistanceCutoffStart, 0f, 1000.0f);
					if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "AO Cutoff start");
						prism.aoDistanceCutoffStart = aoStartD;
					}

					EditorGUI.BeginChangeCheck ();
					float aoRangeD = EditorGUILayout.Slider (aoCutoffRangeContent, prism.aoDistanceCutoffLength, 0f, 150f);
					if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "ao Cutoff range");
						prism.aoDistanceCutoffLength = aoRangeD;
					}
//End
				}

                EditorGUI.BeginChangeCheck();
                float aocont = EditorGUILayout.Slider(aoContrastContent, prism.aoContrast, 0f, 1.0f);
                if (EditorGUI.EndChangeCheck())
                {
                    Undo.RecordObject(target, "AO cont");
                    prism.aoContrast = aocont;
                }
            }


			EditorGUI.BeginChangeCheck ();
			bool aoDebug = EditorGUILayout.Toggle (aoDebugContent, prism.aoShowDebug);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "a debg");
				prism.aoShowDebug = aoDebug;
			}

		}



		GUILayout.Space (1f);

//Chromatic
		EditorGUILayout.BeginHorizontal ();

		prism.useChromaticAberration = EditorGUILayout.Toggle (chromaticContent, prism.useChromaticAberration);

		EditorGUILayout.EndHorizontal ();

		if (prism.useChromaticAberration)
			showChromatic = EditorGUILayout.Foldout (showChromatic, " >Show Chromatic Values");

		if (prism.useChromaticAberration && showChromatic) {
			EditorGUI.BeginChangeCheck ();
			AberrationType chromAbType = (AberrationType)EditorGUILayout.EnumPopup (chromaticTypeContent, prism.aberrationType);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Aber type");
				prism.aberrationType = chromAbType;
			}

			float minChromIntens = 0f;
			float maxChromIntens = 0.15f;
			float maxChromOne = 1f;

			if(prism.aberrationType == AberrationType.Barrel)
			{
				minChromIntens = 0.05f;
				maxChromIntens = 0.15f;
			}

			EditorGUI.BeginChangeCheck ();
			float chromInten = EditorGUILayout.Slider (chromaticIntensityContent, prism.chromaticIntensity, minChromIntens, maxChromIntens);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Chrom intens");
				if (prism.aberrationType == AberrationType.Vertical) {
					prism.chromaticIntensity = chromInten;
				} else {
					prism.chromaticIntensity = chromInten;
				}
			}

			if(prism.aberrationType == AberrationType.Barrel)
			{
				maxChromOne = 0.15f;
			}

			EditorGUI.BeginChangeCheck ();
			float chromOne = EditorGUILayout.Slider ("   >Chromatic Start", prism.chromaticDistanceOne, 0f, maxChromOne);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Chrom 1");

				prism.chromaticDistanceOne = chromOne;
			}

			if(prism.aberrationType != AberrationType.Barrel)
			{
				EditorGUI.BeginChangeCheck ();
				float chromTwo = EditorGUILayout.Slider ("   >Chromatic End", prism.chromaticDistanceTwo, 0f, 1f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Chrom 2");
					prism.chromaticDistanceTwo = chromTwo;
				}
			}

			EditorGUI.BeginChangeCheck ();
			bool chromBlur = EditorGUILayout.Toggle (chromaticBlurContent, prism.useChromaticBlur);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Chrom b");
				prism.useChromaticBlur = chromBlur;
			}

			if (prism.useChromaticBlur) {
				EditorGUI.BeginChangeCheck ();
				float chromBlurWidth = EditorGUILayout.Slider (chromaticBlurWidthContent, prism.chromaticBlurWidth, 0f, 0.01f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Chrom blur width");
					prism.chromaticBlurWidth = chromBlurWidth;
				}
			}

		}


		GUILayout.Space (1f);

//Vignette
		EditorGUILayout.BeginHorizontal ();

		prism.useVignette = EditorGUILayout.Toggle (vignetteContent, prism.useVignette);

		EditorGUILayout.EndHorizontal ();

		if (prism.useVignette)
			showVignette = EditorGUILayout.Foldout (showVignette, " >Show Vignette Values");

		if (prism.useVignette && showVignette) {
			EditorGUI.BeginChangeCheck ();
			float vigI = EditorGUILayout.Slider ("   >Vignette Intensity", prism.vignetteStrength, 0f, 1f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Vig 3");
				prism.vignetteStrength = vigI;
			}

			EditorGUI.BeginChangeCheck ();
			Color vigCol = EditorGUILayout.ColorField ("   >Vignette Color", prism.vignetteColor);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Vig color");
				prism.vignetteColor = vigCol;
			}

/*EditorGUI.BeginChangeCheck();
bool advVignette = EditorGUILayout.Toggle(advVignetteContent, prism.advancedVignette);
if(EditorGUI.EndChangeCheck())
{
Undo.RecordObject(target, "Advanced vignette");
prism.advancedVignette = advVignette;
}*/

//if(prism.advancedVignette)
//{
			EditorGUI.BeginChangeCheck ();
			float vigOne = EditorGUILayout.Slider ("   >Vignette Start", prism.vignetteEnd, 0f, 1f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Vig 1");
				prism.vignetteEnd = vigOne;
			}

			EditorGUI.BeginChangeCheck ();
			float vigTwo = EditorGUILayout.Slider ("   >Vignette End", prism.vignetteStart, 0f, 1f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Vig 2");
				prism.vignetteStart = vigTwo;
			}
//}
		}



		GUILayout.Space (1f);

//Filmic Grain
		EditorGUILayout.BeginHorizontal ();

		prism.useNoise = EditorGUILayout.Toggle (noiseContent, prism.useNoise);

		EditorGUILayout.EndHorizontal ();

		if (prism.useNoise)
			showNoise = EditorGUILayout.Foldout (showNoise, " >Show Noise Values");

		if (prism.useNoise && showNoise) {
			EditorGUI.BeginChangeCheck ();
			float noiseIntens = EditorGUILayout.Slider (noiseIntensityContent, prism.noiseIntensity, 0f, 1f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Noise intens");
				prism.noiseIntensity = noiseIntens;
			}

			if (GUILayout.Button ("  >Reset to dither amount")) {
				prism.noiseIntensity = 0.05f;
			}
		}



		GUILayout.Space (1f);

//Tonemap
		EditorGUILayout.BeginHorizontal ();

		prism.useTonemap = EditorGUILayout.Toggle (tonemapContent, prism.useTonemap);

		EditorGUILayout.EndHorizontal ();

		if (prism.useTonemap)
			showTonemap = EditorGUILayout.Foldout (showTonemap, " >Show Tonemap Values");

		if (prism.useTonemap && showTonemap) {
			if (QualitySettings.activeColorSpace == ColorSpace.Gamma) {
				if (!PrismEffectsEditor.hasDisplayedTonemapWarning) {
					Debug.LogWarning ("Warning - you are trying to use a tonemap while using Gamma color space. It is advised to change this to Linear in your player settings.");
					PrismEffectsEditor.hasDisplayedTonemapWarning = true;
				}
			}

			if (prism.GetPrismCamera ().allowHDR == false) {
				if (!PrismEffectsEditor.hasDisplacedHDRWarning) {
					Debug.LogWarning ("Warning - you are trying to use a tonemap on a non-HDR camera. Consider changing your camera to HDR.");
					PrismEffectsEditor.hasDisplacedHDRWarning = true;
				}
			}

			EditorGUI.BeginChangeCheck ();
			TonemapType toneType = (TonemapType)EditorGUILayout.EnumPopup (tonemapTypeContent, prism.tonemapType);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Tonemap type");
				prism.tonemapType = toneType;
				if (toneType == TonemapType.Filmic) {
					prism.ResetToneParamsFilmic ();
				} else if (toneType == TonemapType.RomB) {
					prism.ResetToneParamsRomB ();
				} else if (toneType == TonemapType.ACES) {
					prism.ResetToneParamsACES ();
				}
			}

			showToneParams = true;//EditorGUILayout.Toggle(tonemapShowParamsContent, showToneParams);
			if (showToneParams) {
//Tell user about values
				if (toneType == TonemapType.Filmic) {
					//EditorGUILayout.HelpBox ("X value controls the white point of the filmic tonemap. It is recommended to not alter other values, and use color correction to apply color modifications.", MessageType.Info);
				}

				if (toneType == TonemapType.RomB) {
					EditorGUILayout.HelpBox ("Y value controls the white point of the RomB tonemap. It is recommended to not alter other values, and use color correction to apply color modifications.", MessageType.Info);
				}

				if (toneType == TonemapType.ACES) {
					EditorGUILayout.HelpBox ("X value controls the white point of the ACES tonemap. It is recommended to not alter other values, and use color correction to apply color modifications.", MessageType.Info);
				}

				if (toneType != TonemapType.Filmic)
				{
					EditorGUI.BeginChangeCheck ();
					Vector3 toneStuff = EditorGUILayout.Vector3Field (tonemapParamsContent, prism.toneValues);
					if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "Tone Params");
						prism.toneValues = toneStuff;
					}
					
					if (toneType != TonemapType.RomB) {
						EditorGUI.BeginChangeCheck ();
						Vector3 tone2Stuff = EditorGUILayout.Vector3Field (tonemapSecondaryParamsContent, prism.secondaryToneValues);
						if (EditorGUI.EndChangeCheck ()) {
							Undo.RecordObject (target, "Tone 2Params");
							prism.secondaryToneValues = tone2Stuff;
						}
					}
				}

			}			
		}


		GUILayout.Space (1f);

//Adapt
		EditorGUILayout.BeginHorizontal ();

		prism.useExposure = EditorGUILayout.Toggle (exposureAdaptContent, prism.useExposure);

		EditorGUILayout.EndHorizontal ();

		if (prism.useExposure)
			showExposure = EditorGUILayout.Foldout (showExposure, " >Show Exposure Values");

		if (prism.useExposure && showExposure) {
			EditorGUI.BeginChangeCheck ();
			float exSpeed = EditorGUILayout.Slider (exposureSpeedContent, prism.exposureSpeed, 0f, 20f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Exposure speed");
				prism.exposureSpeed = exSpeed;
			}

			EditorGUI.BeginChangeCheck ();
			float exOffset = EditorGUILayout.Slider (exposureOffsetContent, prism.exposureMiddleGrey, 0f, 1f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Exposure offset");
				prism.exposureMiddleGrey = exOffset;
			}

			EditorGUI.BeginChangeCheck ();
			float exLower = EditorGUILayout.Slider (exposureMinContent, prism.exposureLowerLimit, -10f, 0f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Exposure lower");
				prism.exposureLowerLimit = exLower;
			}

			EditorGUI.BeginChangeCheck ();
			float exUpper = EditorGUILayout.Slider (exposureMatContent, prism.exposureUpperLimit, 0f, 10f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Exposure upper");
				prism.exposureUpperLimit = exUpper;
			}

			EditorGUI.BeginChangeCheck ();
			bool dbgExposure = EditorGUILayout.Toggle (exposureDebugContent, prism.debugViewExposure);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Use debug exposure");
				prism.debugViewExposure = dbgExposure;
			}
		}
		GUILayout.Space (1f);
//Lut
		EditorGUILayout.BeginHorizontal ();

		EditorGUI.BeginChangeCheck ();
		bool useLt = EditorGUILayout.Toggle (lutContent, prism.useLut);
		if (EditorGUI.EndChangeCheck ()) {
			Undo.RecordObject (target, "Lut");
			prism.useLut = useLt;

			if (useLt == true) {
				prism.enabled = false;
				prism.enabled = true;
			}
		}

		EditorGUILayout.EndHorizontal ();

		if (prism.useLut)
			showLut = EditorGUILayout.Foldout (showLut, " >Show LUT Values");

		if (prism.useLut && showLut) {
			Rect r; 
			Texture2D t;

			EditorGUI.BeginChangeCheck ();

			tempClutTex2D = EditorGUILayout.ObjectField (lutInfoContent, tempClutTex2D, typeof(Texture2D), false) as Texture2D;
			if (tempClutTex2D == null) {
				t = prism.twoDLookupTex;
				if (t)
					tempClutTex2D = t;
			}

			Texture2D tex = tempClutTex2D;

			if (EditorGUI.EndChangeCheck ()) {
				Debug.LogWarning ("Converting");
				prism.Convert (tex);
			}

			if (prism.twoDLookupTex)
			if (tex && prism.basedOnTempTex != prism.twoDLookupTex.name) {
				EditorGUILayout.Separator ();
				if (!prism.ValidDimensions (tex)) {
					EditorGUILayout.HelpBox ("Invalid texture dimensions!\nPick another texture or adjust dimension to e.g. 256x16.", MessageType.Warning);
				} else if (!prism.enabled) {

				} else if (GUILayout.Button ("Convert and Apply LUT!")) {
					string path = AssetDatabase.GetAssetPath (tex);
					TextureImporter textureImporter = AssetImporter.GetAtPath (path) as TextureImporter;
					bool doImport = textureImporter.isReadable == false;
					if (textureImporter.mipmapEnabled == true) {
						doImport = true;
					}
//if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
//	doImport = true;
//}

					if (doImport) {
						textureImporter.isReadable = true;
						textureImporter.mipmapEnabled = false;
//textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
						AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
					}

					prism.Convert (tex);
				}
			}

			if (prism.threeDLookupTex != null && prism.twoDLookupTex != null) {
				EditorGUILayout.BeginHorizontal ();
				GUILayout.Space (150f);
				if (GUILayout.Button ("Flip LUT (fixes Amplify Color LUTs)")) {
					prism.twoDLookupTex = FlipTexture (prism.twoDLookupTex);
					prism.Reset ();
					OnEnable ();
				}
				EditorGUILayout.EndHorizontal ();

				EditorGUI.BeginChangeCheck ();
				float lutI = EditorGUILayout.Slider ("   >LUT Intensity", prism.lutLerpAmount, 0f, 1f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Lut intense");
					prism.lutLerpAmount = lutI;
				}

				if (prism.basedOnTempTex == "") {
					string pth = prism.twoDLookupTex.name;
					prism.basedOnTempTex = pth;
				}

				EditorGUILayout.LabelField ("   >Using: " + prism.basedOnTempTex);
				t = prism.twoDLookupTex;
				if (t) {
					r = GUILayoutUtility.GetLastRect ();
					r = GUILayoutUtility.GetRect (r.width, 20);
					r.x += r.width * 0.05f / 2.0f;
					r.width *= 0.95f;
					GUI.DrawTexture (r, t);
					GUILayoutUtility.GetRect (r.width, 4);
				}
			}

			EditorGUI.BeginChangeCheck ();
			bool secc = EditorGUILayout.Toggle (lutSecondaryInfoContent, prism.useSecondLut);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Use 2sec");
				prism.useSecondLut = secc;
			}

			if (prism.useSecondLut) {
				Rect r2; 
				Texture2D t2;

				EditorGUI.BeginChangeCheck ();

				tempSecondClutTex2D = EditorGUILayout.ObjectField (lutInfoContent, tempSecondClutTex2D, typeof(Texture2D), false) as Texture2D;
				if (tempSecondClutTex2D == null) {
					t2 = prism.secondaryTwoDLookupTex;
					if (t2)
						tempSecondClutTex2D = t2;
				}

				Texture2D tex2 = tempSecondClutTex2D;

				if (EditorGUI.EndChangeCheck ()) {
					Debug.LogWarning ("Converting 2nd LUT");
					prism.Convert (tex2, true);
					prism.Reset ();
				}

				if (tex2 && prism.secondaryTwoDLookupTex != null && prism.secondaryBasedOnTempTex != prism.secondaryTwoDLookupTex.name) {
					EditorGUILayout.Separator ();
					if (!prism.ValidDimensions (tex2)) {
						EditorGUILayout.HelpBox ("Invalid texture dimensions for LUT 2!\nPick another texture or adjust dimension to e.g. 256x16.", MessageType.Warning);
					} else if (prism.enabled == false) {

					} else if (GUILayout.Button ("Convert and Apply LUT 2!")) {
						string path = AssetDatabase.GetAssetPath (tex2);
						TextureImporter textureImporter = AssetImporter.GetAtPath (path) as TextureImporter;
						bool doImport = textureImporter.isReadable == false;
						if (textureImporter.mipmapEnabled == true) {
							doImport = true;
						}
//if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
//	doImport = true;
//}

						if (doImport) {
							textureImporter.isReadable = true;
							textureImporter.mipmapEnabled = false;
//textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
							AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
						}

						prism.Convert (tex2, true);
					}
				}

				if (prism.secondaryThreeDLookupTex != null && prism.secondaryTwoDLookupTex != null) {
					EditorGUILayout.BeginHorizontal ();
					GUILayout.Space (150f);
					if (GUILayout.Button ("Flip LUT (fixes Amplify Color LUTs)")) {
						prism.twoDLookupTex = FlipTexture (prism.secondaryTwoDLookupTex);
						prism.Reset ();
						OnEnable ();
					}
					EditorGUILayout.EndHorizontal ();

					EditorGUI.BeginChangeCheck ();
					float lutI2 = EditorGUILayout.Slider ("   >Second LUT Intensity", prism.secondaryLutLerpAmount, 0f, 1f);
					if (EditorGUI.EndChangeCheck ()) {
						Undo.RecordObject (target, "Lut intense");
						prism.secondaryLutLerpAmount = lutI2;
					}

					if (prism.secondaryBasedOnTempTex == "") {
						string pth2 = prism.secondaryTwoDLookupTex.name;
						prism.secondaryBasedOnTempTex = pth2;
					}

					EditorGUILayout.LabelField ("   >Using: " + prism.secondaryBasedOnTempTex);
					t2 = prism.secondaryTwoDLookupTex;
					if (t2) {
						r2 = GUILayoutUtility.GetLastRect ();
						r2 = GUILayoutUtility.GetRect (r2.width, 20);
						r2.x += r2.width * 0.05f / 2.0f;
						r2.width *= 0.95f;
						GUI.DrawTexture (r2, t2);
						GUILayoutUtility.GetRect (r2.width, 4);
					}
				}
			}
		}

//Nightvisionx

		GUILayout.Space (1f);

//Rays
		/*EditorGUILayout.BeginHorizontal ();

		EditorGUI.BeginChangeCheck ();
		prism.useRays = EditorGUILayout.Toggle (raysContent, prism.useRays);
		if (EditorGUI.EndChangeCheck ()) {
			if (!prism.rayTransform) {
				var sunsInScene = FindObjectsOfType (typeof(Light)) as Light[];
				foreach (var v in sunsInScene) {
					if (v.type == LightType.Directional) {
						prism.rayTransform = v.transform;
					}
				}
			}
		}

		EditorGUILayout.EndHorizontal ();

		if (prism.useRays)
			showRays = EditorGUILayout.Foldout (showRays, " >Show Godrays Values");

		if (prism.useRays && showRays) {	
			EditorGUI.BeginChangeCheck ();
			float rWgt = EditorGUILayout.Slider (raysWeightContent, prism.rayWeight, 0f, 1f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Ray weight");
				prism.rayWeight = rWgt;
			}

			EditorGUI.BeginChangeCheck ();
			Color rayCol = EditorGUILayout.ColorField (raysColorContent, prism.rayColor, true, true, true, defaultHDRColorPicker);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Ray color");
				prism.rayColor = rayCol;
			}

			EditorGUI.BeginChangeCheck ();
			Color rayThresh = EditorGUILayout.ColorField (raysThresholdContent, prism.rayThreshold, true, true, true, defaultHDRColorPicker);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Ray trhesh color");
				prism.rayThreshold = rayThresh;
			}

			EditorGUI.BeginChangeCheck ();
			Transform raysT = (Transform)EditorGUILayout.ObjectField (raysCasterContent, prism.rayTransform, typeof(Transform), true);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Rays transform");
				prism.rayTransform = raysT;
			}

			EditorGUI.BeginChangeCheck ();
			bool dbgRs = EditorGUILayout.Toggle (raysDebugContent, prism.raysShowDebug);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Use debug rays");
				prism.raysShowDebug = dbgRs;
			}

			EditorGUI.BeginChangeCheck ();
			bool advRs = EditorGUILayout.Toggle (raysAdvancedContent, showAdvancedRays);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Use adv rays");
				showAdvancedRays = advRs;
			}

			if(showAdvancedRays)
			{
				EditorGUI.BeginChangeCheck ();
				float rDecay = EditorGUILayout.Slider (rayDecayContent, prism.rayDecay, 0.5f, 1.0f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Ray Decay");
					prism.rayDecay = rDecay;
				}

				EditorGUI.BeginChangeCheck ();
				float rExp = EditorGUILayout.Slider (rayExposureContent, prism.rayExposure, 0f, 0.5f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Ray Exposure");
					prism.rayExposure = rExp;
				}

				EditorGUI.BeginChangeCheck ();
				float rDens = EditorGUILayout.Slider (rayDensityContent, prism.rayDensity, 0f, 1.2f);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Ray Density");
					prism.rayDensity = rDens;
				}

				EditorGUI.BeginChangeCheck ();
				RaysDownsampleAmount rayDS = (RaysDownsampleAmount)EditorGUILayout.EnumPopup (rayDownsampleContent, prism.rayDownsample);
				if (EditorGUI.EndChangeCheck ()) {
					Undo.RecordObject (target, "Raydownsample");
					prism.rayDownsample = rayDS;
				}
			}
		}

		GUILayout.Space (1f);
*/
		EditorGUI.BeginChangeCheck ();
		bool useBright = EditorGUILayout.Toggle (brightContent, prism.useBrightness);
		if (EditorGUI.EndChangeCheck ()) {
			Undo.RecordObject (target, "Use brightness");
			prism.useBrightness = useBright;
		}

		if (prism.useBrightness) {
			EditorGUI.BeginChangeCheck ();
			float brtInt = EditorGUILayout.Slider (brightIntensityContent, prism.brightIntensity, 0.001f, 0.8f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Brt Intens");
				prism.brightIntensity = brtInt;
			}		

			EditorGUI.BeginChangeCheck ();
			float brtCut = EditorGUILayout.Slider (brightCutoffContent, prism.brightCutoff, 0.0001f, 0.3f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Brt cutoff");
				prism.brightCutoff = brtCut;
			}

			EditorGUI.BeginChangeCheck ();
			float brtSoft = EditorGUILayout.Slider (brightSoftnessContent, prism.brightSoftness, 0f, 2.0f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Brt soft");
				prism.brightSoftness = brtSoft;
			}
		}


		GUILayout.Space (1f);

		EditorGUI.BeginChangeCheck ();
		bool useGamma = EditorGUILayout.Toggle (gammaCorrectionContent, prism.useGammaCorrection);
		if (EditorGUI.EndChangeCheck ()) {
			Undo.RecordObject (target, "Use gamma");
			prism.useGammaCorrection = useGamma;
		}

		if (prism.useGammaCorrection) {
			EditorGUI.BeginChangeCheck ();
			float gamValue = EditorGUILayout.Slider (gammaValueContent, prism.gammaValue, 0.4f, 2.5f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "Gamma");
				prism.gammaValue = gamValue;
			}
		}

//Color
		GUILayout.Space (1f);

		EditorGUI.BeginChangeCheck ();
		bool useColorify = EditorGUILayout.Toggle (colorifyContent, prism.useColorify);
		if (EditorGUI.EndChangeCheck ()) {
			Undo.RecordObject (target, "Use colorify");
			prism.useColorify = useColorify;
		}

		if (prism.useColorify) {
			EditorGUI.BeginChangeCheck ();
			float colorAmount = EditorGUILayout.Slider (colorifyAmountContent, prism.colorifyAmount, 0.1f, 0.5f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "colorify");
				prism.colorifyAmount = colorAmount;
			}
		}

//Sharpen
		GUILayout.Space (1f);

		EditorGUI.BeginChangeCheck ();
		bool useSharpen = EditorGUILayout.Toggle (sharpenContent, prism.useSharpen);
		if (EditorGUI.EndChangeCheck ()) {
			Undo.RecordObject (target, "Use sharpen");
			prism.useSharpen = useSharpen;
		}

		if (prism.useSharpen) {
			EditorGUI.BeginChangeCheck ();
			float sharpAmount = EditorGUILayout.Slider (sharpenIntensityContent, prism.sharpenAmount, 0.0f, 1.0f);
			if (EditorGUI.EndChangeCheck ()) {
				Undo.RecordObject (target, "sharpen");
				prism.sharpenAmount = sharpAmount;
			}
		}

		if (GUI.changed) {
			needsToSave = true;
//this.OnEnable();
//Debug.LogError("Gui changed");
			EditorUtility.SetDirty (target);

			if (prism.useLut == true && prism.useSecondLut == true && prism.secondaryTwoDLookupTex != null && prism.secondaryBasedOnTempTex != prism.secondaryTwoDLookupTex.name) {
				prism.Convert (prism.secondaryTwoDLookupTex, true);
			}

			if (prism.useLut == true && prism.twoDLookupTex != null && prism.basedOnTempTex != prism.twoDLookupTex.name) {
				prism.Convert (prism.twoDLookupTex);
			}	
		}

		serObj.ApplyModifiedProperties ();

	}

	void ResetCurrentEffectsString (PrismEffects prism)
	{
		currentEffectsString = "";
		int numEffects = 0;

		if (prism.useBloom) {
			currentEffectsString += " Bloom,";
			numEffects++;
		}// EditorGUILayout.LabelField("Bloom");

		if (prism.useFog) {
			currentEffectsString += " Fog,";
			numEffects++;
		}//EditorGUILayout.LabelField("Night vision");

		if (prism.useDof) {
			currentEffectsString += " Depth of field,";
			numEffects++;
		}//EditorGUILayout.LabelField("Depth of field");

		if (prism.useAmbientObscurance) {
			currentEffectsString += " AO,";
			numEffects++;
		}

		if (prism.useChromaticAberration) {
			currentEffectsString += " Chromatic aberration,";
			numEffects++;
		}//EditorGUILayout.LabelField("Chromatic aberration");

		if (prism.useVignette) {
			currentEffectsString += " Vignette,";
			numEffects++;
		}//EditorGUILayout.LabelField("Vignette");

		if (prism.useNoise) {
			currentEffectsString += " Filmic grain,";
			numEffects++;
		}//EditorGUILayout.LabelField("Filmic grain");

		if (prism.useSharpen) {
			currentEffectsString += " Sharpen,";
			numEffects++;
		}//EditorGUILayout.LabelField("Sharpen");

		if (prism.useColorify) {
			currentEffectsString += " Colorify,";
			numEffects++;
		}//EditorGUILayout.LabelField("Sharpen");

		if (prism.useBrightness) {
			currentEffectsString += " Brightness,";
			numEffects++;
		}//EditorGUILayout.LabelField("Sharpen");

//if(prism.useNightVision) { currentEffectsString += " Night vision,"; numEffects++;}//EditorGUILayout.LabelField("Night vision");

		if (prism.useTonemap) {
			currentEffectsString += " Tonemapping,";
			numEffects++;
		}//EditorGUILayout.LabelField("Night vision");

		if (prism.useExposure) {
			currentEffectsString += " Exposure Adaptation,";
			numEffects++;
		}//EditorGUILayout.LabelField("Night vision");

		if (prism.useGammaCorrection) {
			currentEffectsString += " Gamma Correction,";
			numEffects++;
		}//EditorGUILayout.LabelField("Night vision");

		if (prism.useLut) {
			currentEffectsString += " Color correction,";
			numEffects++;
		}//EditorGUILayout.LabelField("Night vision");

		if (prism.useRays) {
			currentEffectsString += " Godrays,";
			numEffects++;
		}//EditorGUILayout.LabelField("Night vision");
	}

	[MenuItem("Assets/Create/PRISM Preset")]
	public static void CreatePrismPresetAsset ()
	{
		PrismPreset asset = ScriptableObject.CreateInstance<PrismPreset> ();

		string path = AssetDatabase.GetAssetPath (Selection.activeObject);
		if (path == "") {
			path = "Assets";
		} else if (Path.GetExtension (path) != "") {
			path = path.Replace (Path.GetFileName (AssetDatabase.GetAssetPath (Selection.activeObject)), "");
		}

		string assetPathAndName = AssetDatabase.GenerateUniqueAssetPath (path + "/New " + "PRISMPreset.Asset");

		AssetDatabase.CreateAsset (asset, assetPathAndName);
		AssetDatabase.SaveAssets ();

//EditorUtility.FocusProjectWindow();

		Selection.activeObject = asset;

	}

	void SaveValuesToPreset (PrismEffects prism, PrismPreset preset)
	{
		preset.useBloom = prism.useBloom;
		preset.bloomDownsample = prism.bloomDownsample;
		preset.bloomBlurPasses = prism.bloomBlurPasses;
		preset.bloomIntensity = prism.bloomIntensity;
		preset.bloomThreshold = prism.bloomThreshold;
		preset.useBloomStability = prism.useBloomStability;
		preset.bloomType = prism.bloomType;
		preset.useFullScreenBlur = prism.useFullScreenBlur;
		preset.bloomUseScreenBlend = prism.bloomUseScreenBlend;
		preset.bloomDownsampleEnum = prism.bloomDownsampleEnum;
		preset.bloomThreshType = prism.bloomThreshType;
		preset.bloomKnee = prism.bloomKnee;
		preset.bloomRadius = prism.bloomRadius;

		preset.useBloomLensdirt = prism.useLensDirt;
		preset.bloomLensdirtIntensity = prism.dirtIntensity;
		preset.bloomLensdirtTexture = prism.lensDirtTexture;
		preset.bloomFlareLensDirtIntensityMultiplier = prism.bloomFlareLensDirtIntensityMultiplier;

		preset.bloomOneIntensity = prism.bloomOneIntensity;
		preset.bloomTwoIntensity = prism.bloomTwoIntensity;
		preset.bloomThreeIntensity = prism.bloomThreeIntensity;
		preset.bloomFourIntensity = prism.bloomFourIntensity;

		preset.uiBlurGrabTextureFromPassNumber = prism.uiBlurGrabTextureFromPassNumber;
		preset.useUIBlur = prism.useUIBlur;

		preset.bloomFlareStarburstTex = prism.bloomFlareStarburstTex;

		preset.bloomFlareStrength = prism.bloomFlareStrength;
		preset.bloomFlareHaloWidth = prism.bloomFlareHaloWidth;
		preset.bloomFlareGhostDispersal = prism.bloomFlareGhostDispersal;
		preset.bloomFlareChromaticDistortion = prism.bloomFlareChromaticDistortion;
		preset.bloomFlareNumberGhosts = prism.bloomFlareNumberGhosts;

		preset.useDoF = prism.useDof;
		preset.dofRadius = prism.dofRadius;
		preset.dofSampleCount = prism.dofSampleAmount;
		preset.dofBokehFactor = prism.dofBokehFactor;
		preset.dofFocusPoint = prism.dofFocusPoint;
		preset.dofFocusDistance = prism.dofFocusDistance;
		preset.useNearBlur = prism.useNearDofBlur;
		preset.dofBlurSkybox = prism.dofBlurSkybox;
		preset.dofNearFocusDistance = prism.dofNearFocusDistance;
		preset.dofForceEnableMedian = prism.dofForceEnableMedian;
		preset.dofDownsample = prism.dofDownsample;

		preset.useChromaticAb = prism.useChromaticAberration;
		preset.aberrationType = prism.aberrationType;
		preset.chromIntensity = prism.chromaticIntensity;
		preset.chromStart = prism.chromaticDistanceOne;
		preset.chromEnd = prism.chromaticDistanceTwo;
		preset.useChromaticBlur = prism.useChromaticBlur;
		preset.chromaticBlurWidth = prism.chromaticBlurWidth;

		preset.useVignette = prism.useVignette;
		preset.vignetteIntensity = prism.vignetteStrength;
		preset.vignetteEnd = prism.vignetteEnd;
		preset.vignetteStart = prism.vignetteStart;
		preset.vignetteColor = prism.vignetteColor;

		preset.useNoise = prism.useNoise;
		preset.noiseIntensity = prism.noiseIntensity;

		preset.useTonemap = prism.useTonemap;
		preset.toneType = prism.tonemapType;
		preset.toneValues = prism.toneValues;
		preset.secondaryToneValues = prism.secondaryToneValues;

		preset.useExposure = prism.useExposure;
		preset.exposureMiddleGrey = prism.exposureMiddleGrey;
		preset.exposureLowerLimit = prism.exposureLowerLimit;
		preset.exposureUpperLimit = prism.exposureUpperLimit;
		preset.exposureSpeed = prism.exposureSpeed;

		preset.useGammaCorrection = prism.useGammaCorrection;
		preset.gammaValue = prism.gammaValue;

		preset.useLUT = prism.useLut;
		preset.lutIntensity = prism.lutLerpAmount;
		preset.lutPath = prism.basedOnTempTex;
		preset.twoDLookupTex = prism.twoDLookupTex;

		preset.useSecondLut = prism.useSecondLut;
		preset.secondaryLutLerpAmount = prism.secondaryLutLerpAmount;
		preset.secondaryLutPath = prism.secondaryBasedOnTempTex;
		preset.secondaryTwoDLookupTex = prism.secondaryTwoDLookupTex;

		preset.useFog = prism.useFog;
		preset.fogAffectSkybox = prism.fogAffectSkybox;
		preset.fogIntensity = prism.fogIntensity;
		preset.fogStartPoint = prism.fogStartPoint;
		preset.fogDistance = prism.fogDistance;
		preset.fogColor = prism.fogColor;
		preset.fogColor = prism.fogColor;
		preset.fogEndColor = prism.fogEndColor;
		preset.fogHeight = prism.fogHeight;

		preset.fogEndPoint = prism.fogEndPoint;
		preset.fogMidPoint = prism.fogMidPoint;
		preset.fogMidColor = prism.fogMidColor;

		preset.useAmbientObscurance = prism.useAmbientObscurance;
		preset.aoIntensity = prism.aoIntensity;
		preset.aoRadius = prism.aoRadius;
		preset.aoDownsample = prism.aoDownsample;
		preset.aoBlurIterations = prism.aoBlurIterations;
		preset.aoSampleCount = prism.aoSampleCount;
		preset.useAODistanceCutoff = prism.useAODistanceCutoff;
		preset.aoDistanceCutoffStart = prism.aoDistanceCutoffStart;
		preset.aoDistanceCutoffLength = prism.aoDistanceCutoffLength;
		preset.aoBias = prism.aoBias;
		preset.aoBlurType = prism.aoBlurType;
		preset.aoLightingContribution = prism.aoLightingContribution;
		preset.occlusionSource = prism.occlusionSource;
        preset.aoContrast = prism.aoContrast;

		preset.useRays = prism.useRays;
		preset.rayWeight = prism.rayWeight;
		preset.rayColor = prism.rayColor;
		preset.rayThreshold = prism.rayThreshold;
		preset.rayDensity = prism.rayDensity;
		preset.rayDecay = prism.rayDecay;
		preset.rayExposure = prism.rayExposure;
		preset.rayDownsample = prism.rayDownsample;

		preset.useSharpen = prism.useSharpen;
		preset.sharpenAmount = prism.sharpenAmount;

		preset.useColorify = prism.useColorify;
		preset.colorifyAmount = prism.colorifyAmount;	

		preset.useBrightness = prism.useBrightness;
		preset.brightIntensity = prism.brightIntensity;
		preset.brightCutoff = prism.brightCutoff;
		preset.brightSoftness = prism.brightSoftness;

		needsToSave = false;

		Debug.Log ("Saved values to preset: " + preset.name);

		EditorUtility.SetDirty (preset);
		EditorUtility.SetDirty (prism);
	}

	public static Texture2D FlipTexture (Texture2D original)
	{
		Texture2D flipped = new Texture2D (original.width, original.height);

		int xN = original.width;
		int yN = original.height;


		for (int i=0; i<xN; i++) {
			for (int j=0; j<yN; j++) {
				flipped.SetPixel (i, yN - j - 1, original.GetPixel (i, j));
			}
		}
		flipped.Apply (true);

		var bytes = flipped.EncodeToPNG ();

		string path = AssetDatabase.GetAssetPath (original);
		System.IO.File.WriteAllBytes (path, bytes);

		AssetDatabase.Refresh ();
		TextureImporter textureImporter = (TextureImporter)AssetImporter.GetAtPath (path);
		bool doImport = textureImporter.isReadable == false;
		if (textureImporter.mipmapEnabled == true) {
			doImport = true;
		}
//if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
//	doImport = true;
//}

		if (doImport) {
			textureImporter.isReadable = true;
			textureImporter.mipmapEnabled = false;
//textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
			AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
		}

		return AssetDatabase.LoadAssetAtPath (path, typeof(Texture2D)) as Texture2D;

//return flipped;
	}

	void LoadValuesFromPreset (PrismEffects prism, PrismPreset preset)
	{
		if (!preset) {
			return;
		}

		Debug.Log ("Loading values from preset: " + preset.name);

		prism.SetPrismPreset (preset);

		if (preset.presetType == PrismPresetType.ColorCorrection || preset.presetType == PrismPresetType.Full) {
			if (preset.useLUT == true && preset.twoDLookupTex != null) {
				string path = AssetDatabase.GetAssetPath (preset.twoDLookupTex);
				TextureImporter textureImporter = AssetImporter.GetAtPath (path) as TextureImporter;
				bool doImport = textureImporter.isReadable == false;
				if (textureImporter.mipmapEnabled == true) {
					doImport = true;
				}
//if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
//	doImport = true;
//}

				if (doImport) {
					textureImporter.isReadable = true;
					textureImporter.mipmapEnabled = false;
//textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
					AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
				}
			}

			if (preset.useLUT == true && prism.useSecondLut == true && preset.secondaryTwoDLookupTex != null) {
				string path = AssetDatabase.GetAssetPath (preset.secondaryTwoDLookupTex);
				TextureImporter textureImporter = AssetImporter.GetAtPath (path) as TextureImporter;
				bool doImport = textureImporter.isReadable == false;
				if (textureImporter.mipmapEnabled == true) {
					doImport = true;
				}
//if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
//	doImport = true;
//}

				if (doImport) {
					textureImporter.isReadable = true;
					textureImporter.mipmapEnabled = false;
//textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
					AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
				}
			}
		}

		needsToSave = false;

		prism.enabled = false;

		EditorUtility.SetDirty (preset);
		EditorUtility.SetDirty (prism);

		prism.enabled = true;
	}







}
#endif